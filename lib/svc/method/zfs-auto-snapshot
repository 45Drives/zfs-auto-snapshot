#!/usr/bin/ksh

#
# Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#


#
# This SMF method takes snapshots periodically of a zfs filesystem, with
# options to allow the user to keep a limited number of snapshots, or snapshot
# all child datasets. More documentation available at
# http://blogs.sun.com/timf
#
# The service will move itself into maintenance if it's unable to take a snapshot,
# destroy a snapshot as per the snapshot retention policy, or is unable to
# create or update the cron job.
# 



# For interested developers, the main functions here, are schedule_snapshots,
# unschedule_snapshots and take_snapshot : the exit conditions from these
# functions check the state of the service before returning an appropriate
# value. The check_failure method is responsible for checking error codes from
# subprocesses, and when called with a non-zero argument, will degrade the
# service, and log an appropriate error message.






. /lib/svc/share/smf_include.sh

result=$SMF_EXIT_OK

# this function validates the properties in the FMRI passed to it, then
# calls a function to create cron job that schedules a snapshot schedule based
# on the properties set in the service instance.
# $1 is assumed to be a valid FMRI
function schedule_snapshots {

	FMRI=$1
	# FIXME need work in here to actually validate the FMRI props
	FILESYS=$(svcprop -p zfs/fs-name $FMRI)
	INTERVAL=$(svcprop -p zfs/interval $FMRI)
	PERIOD=$(svcprop -p zfs/period $FMRI)
	OFFSET=$(svcprop -p zfs/offset $FMRI)
	
	# for now, we're forcing the offset to be 0 seconds.
	OFFSET=0

	# validate the filesystem
	zfs list $FILESYS 2>&1 1> /dev/null
	check_failure $? "ZFS filesystem does not exist!"

	# remove anything that's there at the moment
	unschedule_snapshots $FMRI		

	add_cron_job $INTERVAL $PERIOD $OFFSET $FMRI
	
	# finally, check our status before we return
	STATE=$(svcprop -p restarter/state $FMRI)
	if [ "${STATE}" == "maintenance" ]
	then
		STATE=1
	else
		STATE=0
	fi	
	return $STATE
}


#
# Adding a cron job that runs exactly every x time-intervals is hard to do
# properly.
#
# For now, what I'm doing, is dividing the interval up into x bite chunks
# and running the cron job that often. The problem comes where the interval
# doesn't evenly divide up into x, leaving us taking to many, or too
# few snapshots at the edge of time intervals.
#
# A new implementation of cron would be nice, but until then, we'll
# just live with this.
#
function add_cron_job { # $INTERVAL $PERIOD $OFFSET $FMRI
	
	case $INTERVAL in
	'minutes')
		TIMES=$(get_divisor 0 59 $PERIOD)
		ENTRY="$TIMES * * * *"		
	;;

	'hours')
		TIMES=$(get_divisor 0 23 $PERIOD)
		ENTRY="0 $TIMES * * *"
	;;

	'days')
		TIMES=$(get_divisor 1 31 $PERIOD)
		ENTRY="0 0 $TIMES * *"
	;;

	'months')
		TIMES=$(get_divisor 1 12 $PERIOD)
		ENTRY="0 0 1 $TIMES *"
	;;
	esac

	# adding a cron job is essentially just looking for an existing entry,
	# removing it, and appending a new one. Neato.
	crontab -l | grep -v "/lib/svc/method/zfs-auto-snapshot $FMRI$" > /tmp/saved-crontab.$$
	echo "${ENTRY} /lib/svc/method/zfs-auto-snapshot $FMRI" >> /tmp/saved-crontab.$$
	crontab /tmp/saved-crontab.$$
	check_failure $? "Unable to add cron job!"

	rm /tmp/saved-crontab.$$
	return 0
}



# this function removes a cron job was taking snapshots of $FMRI
# $1 is assumed to be a valid FMRI
function unschedule_snapshots {

	FMRI=$1
	crontab -l | grep -v "/lib/svc/method/zfs-auto-snapshot $FMRI$" > /tmp/saved-crontab.$$
	crontab /tmp/saved-crontab.$$
	check_failure $? "Unable to unschedule snapshots for $FMRI"
	rm /tmp/saved-crontab.$$

	# finally, check our status before we return
	STATE=$(svcprop -p restarter/state $FMRI)
	if [ "${STATE}" == "maintenance" ]
	then
		STATE=1
	else
		STATE=0
	fi
}


# This function actually takes the snapshot of the filesystem. This is what
# really does the work. We name snapshots based on a standard time format
# $1 is assumed to be a valid FMRI
function take_snapshot {

	FMRI=$1

	DATE=$(date +%F-%H:%M:%S)
	SNAPNAME="zfs-auto-snap-${DATE}"
	FILESYS=$(svcprop -p zfs/fs-name $FMRI)
	KEEP=$(svcprop -p zfs/keep $FMRI)
	SNAP_CHILDREN=$(svcprop -p zfs/snapshot-children $FMRI)
	
	# Ok, now say cheese! It'd be nice if the child snapshotting was
	# atomic, but we don't yet have that in zfs.
	if [ "${SNAP_CHILDREN}" == "true" ]
	then
	   for child in $(zfs list -r -H -o name -t filesystem $FILESYS)
	   do
		destroy_older_snapshots $child $KEEP
		zfs snapshot $child@$SNAPNAME
		check_failure $? "Unable to take snapshot $child@$SNAPNAME."
	   done
        else
  	   destroy_older_snapshots $FILESYS $KEEP
	   zfs snapshot $FILESYS@$SNAPNAME
	   check_failure $? "Unable to take snapshot $FILESYS@$SNAPNAME."
	fi

	# finally, check our status before we return
	STATE=$(svcprop -p restarter/state $FMRI)
	if [ "${STATE}" == "maintenance" ]
	then
		STATE=1
	else
		STATE=0
	fi
	return $STATE
}

# Given a filesystem name, and a limit of the number of snapshots we want
# we destroy all older snapshots of this filesystem whose names begin
# with the text "zfs-auto-snap". Note that here we destroy one more snapshot
# than the "keep" threshold - this is because in the context of calling this
# function, we're already creating one new auto-snapshot.
#
function destroy_older_snapshots {

	FILESYS=$1
	KEEP=$2
	if [ "${KEEP}" == "all" ]
	then
		return 0
	fi
	
	KEEP=$(($KEEP - 1))
	
	# walk through the snapshots, newest first, destroying older ones
	for snapshot in $(zfs list -r -t snapshot -H -o name $FILESYS \
		 | grep $FILESYS@zfs-auto-snap | sort -r)
	do
		if [ $KEEP -le 0 ]
		then
			echo "$snapshot being destroyed as per retention policy."
			zfs destroy $snapshot
			check_failure $? "Unable to destroy $snapshot"
		else
			# don't destroy this one			
			KEEP=$(($KEEP - 1))
		fi
	done
}

# Given the exit status of a command, an integer, 0 if the command completed
# without errors, if the command exited with errors, then we degrade the
# state of this service into maintenance mode. We also log an error message
# as passed into this function.
#
function check_failure { # integer exit status, error message to display
  
   RESULT=$1
   ERR_MSG=$2
   if [ $RESULT -ne 0 ]
   then
	echo "Error: $ERR_MSG"
	echo "Moving service $FMRI to maintenance mode."
	svcadm mark maintenance $FMRI
   fi

}


# Given a range start, end and width of period, return a comma
# separated string of numbers within that range and conforming to
# that period. This isn't ideal, but it'll do for now.
#
function get_divisor { # start period, end period, width of period

    START=$1
    END=$2
    WIDTH=$3
    RANGE=$START
    JUMP=$(( $RANGE + $WIDTH ))

    while [ $JUMP -lt $END ]
    do
	RANGE="$RANGE,$JUMP"
	JUMP=$(( $JUMP + $WIDTH ))
    done
	
    echo $RANGE
}



# Here's the beginning of the main script. As we're a method script for SMF,
# we take start and stop arguments, and assume that the $SMF_FMRI value is being
# set. For start and stop, our task is to create a cron job that will take a
# snapshot of the specified filesystem.
#
# Without start | stop arguments, we assume we're being called from the cron job
# created above, where the argument is the FMRI containing properties we can
# consult to in order to actually take the snapshot.

# $1 start | stop | an FMRI that we want to take snapshots of.
case "$1" in
'start')

	schedule_snapshots $SMF_FMRI
	if [ $? -eq 0 ]
 	then
		result=$SMF_EXIT_OK
	else
		echo "Uhho, something went wrong with $SMF_FMRI"
		result=$SMF_EXIT_ERR_FATAL
	fi
        ;;

'stop')
	unschedule_snapshots $SMF_FMRI
	if [ $? -eq 0 ]
 	then
		result=$SMF_EXIT_OK
	else
		echo "Uhho something went wrong with $SMF_FMRI"
		result=$SMF_EXIT_ERR_FATAL
	fi
        ;;

# the default case, we actually call from the cron job itself that's
# executing this script.
*)
	SMF_FMRI=$1
	# are we being called with the correct argument (an FMRI) ?

	echo $SMF_FMRI | grep "^svc:/"
	if [ $? -eq 0 ]
	then
	   take_snapshot $SMF_FMRI
	   if [ $? -eq 0 ]
	   then
  		result=$SMF_EXIT_OK
   	   else
		result=$SMF_EXIT_ERR_FATAL
	   fi

	else

	   echo "Usage from SMF : zfs-auto-snapshot [start | stop]"
	   echo "Usage from cron: zfs-auto-snapshot svc:/system/filesystem/zfs/auto-snapshot:instance"

       fi
	;;

esac

exit $result
